<?php
// An identity represents something people may know you by, like a Twitter handle or and email address.
// We'll call plain text of the handle (as opposed to the object representing it) an "identifier".
abstract class AddressMachineIdentity {

    var $service;
    var $identifier;

    abstract static public function ForIdentifier($i);

    public function setService($s) {

        $services = array('twitter', 'email');
        if (!in_array($s, $services)) {
            return false;
        }

        $this->service = $s;

        return true;

    }

    public function setIdentifier($id) {

        $this->identifier = $id;

        return true;

    }

    function pathToSignedTempFiles() {
        
        if ($this->identifier == '') {
            syslog(LOG_WARNING, "Cannot get pathToSignedTempFiles - identifier missing");
            return null;
        }

        return AddressMachinePaymentKey::PathToSignedFiles($this->identifier, null, 'temp', $this->service, 'bitcoin');

    }

    function pathToSignedUserFiles() {
        
        if ($this->identifier == '') {
            syslog(LOG_WARNING, "Cannot get pathToSignedUserFiles - identifier missing");
            return null;
        }

        return AddressMachinePaymentKey::PathToSignedFiles($this->identifier, null, 'user', $this->service, 'bitcoin');

    }

    // We keep two kinds of keys (Bitcoin addresses):  
    // User keys are registered by the user.
    // Temp keys are generated by us, in the hope that the user give us an address to pay to later.

    function userBitcoinKeys($publisher = false) {

        return $this->bitcoinKeysForType(ADDRESSMACHINE_KEY_TYPE_USER, $publisher);

    }

    function tempBitcoinKeys($publisher = false) {
        
        return $this->bitcoinKeysForType(ADDRESSMACHINE_KEY_TYPE_TEMP, $publisher);

    }

    function bitcoinKeysForType($keytype, $publisher = false) {

        if (!$keytype) {
            syslog(LOG_WARNING, "Cannot get bitcoinKeysForType - type missing");
            return null;
        }

        if (!$identifier = $this->identifier) {
            syslog(LOG_WARNING, "Cannot get bitcoinKeysForType - identifier missing");
            return null;
        }

        if (!$service = $this->service) {
            syslog(LOG_WARNING, "Cannot get bitcoinKeysForType - service missing");
            return null;
        }

        if (!$dir = AddressMachinePaymentKey::PathToSignedFiles($identifier, null, $service, $keytype, 'bitcoin', $publisher)) {
            syslog(LOG_WARNING, "Cannot get bitcoinKeysForType - could not get path to signed files");
            return null;
        }

        if (!file_exists($dir)) {
            syslog(LOG_DEBUG, "Directory $dir does not exist, bitcoinKeysForType returning an empty array.");
            return array();
        }

        if (!$handle = opendir($dir)) {
            syslog(LOG_WARNING, "Directory $dir exists but could not be read, bitcoinKeysForType returning null.");
            return null;
        }

        $ret = array();

        while (false !== ($entry = readdir($handle))) {

            if ($entry == '.') {
                continue;    
            }

            if ($entry == '..') {
                continue;
            }

            if ($entry == 'list.json') {
                continue;
            }

            $key = new AddressMachinePaymentKey();
            $key->address = $entry;
            $key->identifier = $this->identifier;
            $key->service = $this->service;
            $key->keytype = $keytype;
            $key->paymenttype = 'bitcoin';
            $ret[] = $key;

            syslog(LOG_DEBUG, "Found address entry for $entry .");

        }

        closedir($handle);

        return $ret;

    }

    function allBitcoinKeys() {

        return array_merge((array)$this->userBitcoinKeys(), (array)$this->tempBitcoinKeys());

    }

    function addTempBitcoinKeyByAddress($addr) {
        
        return $this->addBitcoinKeyByAddressAndKeyType($addr, ADDRESSMACHINE_KEY_TYPE_TEMP);
        
    }

    function tempBitcoinKeyCreateIfNecessary() {

        $keys = $this->tempBitcoinKeys();

        if (count($keys) == 0) {
            return $this->createTempBitcoinKey();
        }

        return $keys[0];

    }

    function createTempBitcoinKey() {

    }

    // Create a key object and give it a temporary seed and address
    // ...but don't actually save it yet.
    // We'll communicate the seed to the owner first
    function seededTempKey() {

        if (!$this->identifier) {
            return false;
        }
        
        $key = new AddressMachinePaymentKey();
        $key->identifier = $this->identifier;
        $key->keytype = ADDRESSMACHINE_KEY_TYPE_TEMP; 
        $key->service = $this->service;
        $key->paymenttype = 'bitcoin';
        $key->creationdate = gmdate('Y-m-d H:i:s');
        $key->status = 'active';

        // should populate $key->seed and $key->address
        if (!$key->seed()) {
            return null;
        }

        return $key;

    }

    function tempBitcoinKeyForAddress($addr) {

        return $this->bitcoinKeyForAddressAndKeyType($addr, ADDRESSMACHINE_KEY_TYPE_TEMP);

    }

    function addUserBitcoinKeyByAddress($addr) {

        return $this->addBitcoinKeyByAddressAndKeyType($addr, ADDRESSMACHINE_KEY_TYPE_USER);
        
    }

    function userBitcoinKeyForAddress($addr) {

        return $this->bitcoinKeyForAddressAndKeyType($addr, ADDRESSMACHINE_KEY_TYPE_USER);

    }


    function addBitcoinKeyByAddressAndKeyType($addr, $keytype) {

        if (!$this->identifier) {
            return false;
        }
        
        $key = new AddressMachinePaymentKey();
        $key->identifier = $this->identifier;
        $key->address = $addr;
        $key->keytype = $keytype;
        $key->service = $this->service;
        $key->paymenttype = 'bitcoin';
        $key->creationdate = gmdate('Y-m-d H:i:s');
        $key->status = 'active';

        if ($key->create()) {
            return $key;
        }

        return null;

    }

    function bitcoinKeyForAddressAndKeyType($addr, $keytype) {

        if (!$this->identifier) {
            return false;
        }
        
        $key = new AddressMachinePaymentKey();
        $key->identifier = $this->identifier;
        $key->address = $addr;
        $key->keytype = ADDRESSMACHINE_KEY_TYPE_USER;
        $key->service = $this->service;
        $key->paymenttype = 'bitcoin';

        if ($key->exists()) {
            return $key;
        }

        return null;

    }

}

class AddressMachineTwitterIdentity extends AddressMachineIdentity {

    static public function ForIdentifier($id) {
        $i = new AddressMachineTwitterIdentity();
        $i->service = 'twitter';
        $i->identifier = $id;
        return $i;
    }

}

class AddressMachineEmailIdentity extends AddressMachineIdentity {

    static public function ForIdentifier($id) {
        $i = new AddressMachineEmailIdentity();
        $i->service = 'email';
        $i->identifier = $id;
        return $i;
    }


}

// Internally we call what is commonly called an "address" a key.
// This allows us to differentiate it from the address, which is the hash of the public key.
// In practice we will mostly manage addresses.
class AddressMachinePaymentKey {

    var $address;
    var $identifier;
    var $identifierhash; // On the publisher server we use this because we don't know the unhashed identifier
    var $keytype;
    var $service;
    var $paymenttype;
    var $creationdate;
    var $status; // only "active" implemented so far...

    var $seed; // This is used in the case of temp keys. It's only held here temporarily for sending to the owner.

    static public function ForStdClass($obj) {

        $key = new AddressMachinePaymentKey();
        $key->address = $obj->address;
        $key->identifierhash = $obj->identifierhash;
        $key->keytype = $obj->keytype;
        $key->service = $obj->service;
        $key->paymenttype = $obj->paymenttype;
        $key->creationdate = $obj->creationdate;
        $key->status = 'active';

        return $key;

    }

    function exists() {

            syslog(LOG_DEBUG, "checking for {$this->filename()} .");
        if (!$filename = $this->filename()) {
            syslog(LOG_DEBUG, "File {$this->filename()} does not exist.");
            return null;
        }

        return file_exists($filename);

    }

    function write_file($path, $file, $contents) {

        // If we don't already have a directory for this, create it.
        if (!file_exists($path)) {
            
            if (!mkdir( $path, ADDRESSMACHINE_ADDRESS_DIR_CREATION_MODE, true ) ) {

                // Check again in case it failed because another process made it in the meantime
                if (!file_exists($path)) {
                    syslog(LOG_ERR, "Directory creation failed for path $path.");
                    return false;
                }

            }

        }

        if (!$handle = fopen($file, 'w')) {
                syslog(LOG_ERR, "Could not open file $file to write.");
                return false;
        }
        if (!flock($handle, 2)) {
            fclose($handle);
            syslog(LOG_ERR, "Could not lock file $file to write.");
            return false;
        }
        fputs($handle, $contents);
        fclose($handle);

        return $this->update_index($path);

    }

    function update_index($path) {

        if (!$handle = opendir($path)) {
            syslog(LOG_WARNING, "Directory $path could not be read, update_index returning false.");
            return null;
        }

        $file= $path.'/list.json';

        $obj = new stdClass();
        $obj->active = array();
        $obj->revoked = array();

        while (false !== ($entry = readdir($handle))) {

            if ($entry == '.') {
                continue;    
            }

            if ($entry == '..') {
                continue;
            }

            if ($entry == 'list.json') {
                continue;
            }

            // TODO: When we implement revocation we'll want to check here to see which is which.
            // Until then just assume everything is active.
            $obj->active[] = $entry;

            syslog(LOG_DEBUG, "Found address entry for $entry .");

        }

        closedir($handle);

        $contents = json_encode($obj);

        if (!$handle = fopen($file, 'w')) {
            syslog(LOG_ERR, "Could not open file $file to write.");
            return false;
        }
        if (!flock($handle, 2)) {
            fclose($handle);
            syslog(LOG_ERR, "Could not lock file $file to write.");
            return false;
        }
        fputs($handle, $contents);
        fclose($handle);

        return true;

    }

    function create() {

        if (!$address = $this->address) {
            if (!$publisher) {
                syslog(LOG_WARNING, "Cannot create file for address - address not set.");
                return false;
            }
        }

        if ($this->exists()) {
            syslog(LOG_WARNING, "File already exists, refusing to create.");
            return false;
        }

        if (!$path = $this->path()) {
            syslog(LOG_WARNING, "Creation failed, could not get path to place we create the file.");
            return false;
        }

        $file = $path.'/'.$address;
        $contents = $this->toJSON();

        if (!$this->write_file($path, $file, $contents)) {
            syslog(LOG_ERR, "Failed to write file $file.");
            return false;
        }

        if (!AddressMachinePublisherClient::Publish($contents)) {
            syslog(LOG_WARNING, "Publishing $file failed");
        }

        syslog(LOG_INFO, "Wrote new address $file.");

        return true;

    }

    function delete() {

        if (!$file = $this->filename()) {
            syslog(LOG_ERR, "Cannot get filename for deletion.");
            return false;
        }

        if (!file_exists($file)) {
            syslog(LOG_WARNING, "Cannot delete file $file - does not exist.");
            return false;
        }

        $contents = file_get_contents($file);

        // TODO: Would be better to give the user some warning that the unpublishing may take some time...
        if (!AddressMachinePublisherClient::UnPublish($contents)) {
            syslog(LOG_WARNING, "Unpublishing $file failed, will continue with local delete and hope it gets dealt with later in an rsync job");
        }

        if (!$this->delete_file($file)) {
            syslog(LOG_ERR, "Could not delete file $file.");
            return false;
        }

        syslog(LOG_INFO, "Deleted file $file");

        return true;

    }

    function delete_file($file) {

        if (!@unlink($file)) {
            return false;
        }

        return $this->update_index(dirname($file));

    }

    function toJSON() {

        $obj = new stdClass();
        $payload = new stdClass(); // Wrap the data in a separate payload object. The only other thing we have should be the signature.
        $payload->address = $this->address;    
        //$payload->identifier = $this->identifier; // Don't pass the raw identifier to the publisher - they should only be able to see it if the user looks it up.
        $payload->identifierhash = AddressMachinePaymentKey::IdentifierHash($this->identifier);
        $payload->keytype = $this->keytype;    
        $payload->paymenttype = $this->paymenttype;    
        $payload->creationdate = $this->creationdate;    
        $payload->service = $this->service;    
        $payload->status = $this->status;
        $obj->payload = $payload;
        $obj->gpg_signed_data = AddressMachinePaymentKey::PayloadSignature($payload);
        
        return json_encode($obj);

    }

    function path($publisher = false) {

        if (!$address = $this->address) {
            syslog(LOG_WARNING, "No address, can't make filename.");
            return null;
        }

        if (!$path = AddressMachinePaymentKey::PathToSignedFiles($this->identifier, $this->identifierhash, $this->service, $this->keytype, $this->paymenttype, $publisher)) {
            syslog(LOG_WARNING, "Could not get path to signed files.");
            return null;
        }

        return $path;

    }

    function filename($publisher = false) {

        if (!$address = $this->address) {
            syslog(LOG_WARNING, "Could not make filename - address not set.");
            return null;
        }

        if (!$path= $this->path($publisher)) {
            syslog(LOG_WARNING, "Could not make filename - could not get path to signed files.");
            return null;
        }

        return $path.'/'.$address;

    }

    static function PayloadSignature($payload) {

        require_once 'Crypt/GPG.php'; // From PEAR - the puppet install file should install this on Ubuntu.

        $json = json_encode($payload);

        $gpg = new Crypt_GPG(array('homedir' => ADDRESSMACHINE_GPG_ROOT, 'debug'=>ADDRESSMACHINE_GPG_DEBUG));
        $gpg->addSignKey(ADDRESSMACHINE_GPG_FINGERPRINT, '');
        $signature = $gpg->sign($json, Crypt_GPG::SIGN_MODE_CLEAR);

/*
print "signed data:\n";
print $signature;
print "end signed data:\n";
print "signed with:\n";
print $gpg->exportPublicKey( ADDRESSMACHINE_GPG_FINGERPRINT, true);
print "end signed with:\n";
*/

        return $signature;

    }

    function revoke() {

        return false;

    }

    function isSignatureValid() {

        if (!$filename = $this->filename()) {
            syslog(LOG_DEBUG, "File {$this->filename()} does not exist, cannot validate signature.");
            return false;
        }

        $contents = file_get_contents($filename);

        require_once 'Crypt/GPG.php'; // From PEAR - the puppet install file should install this on Ubuntu.

        // We use the publication root here, although we may still check this when signing under some circumstances.
        $gpg = new Crypt_GPG(array('homedir' => ADDRESSMACHINE_PUBLICATION_GPG_ROOT, 'debug' => ADDRESSMACHINE_GPG_DEBUG));
        $gpg->addSignKey(ADDRESSMACHINE_GPG_FINGERPRINT, '');

/*
$public_key = $gpg->exportPublicKey( ADDRESSMACHINE_GPG_FINGERPRINT, true);
print "\n";
print $public_key;
print "\n";
*/

        $json = json_decode($contents);
        $contents = $json->gpg_signed_data;

/*
print "\n";
print $contents;
print "\n";
*/

//print "verifying: \n";
//print $contents;
//print "end verify: \n";
//var_dump($gpg->verifyFile('/tmp/checkme', $public_key));
        if ($gpg->verify($contents)) {
            //print "verify ok";
            return true;
        } else {
            //print "verify ng";
            return false;
        }

        return $signature;





        $json = json_decode($contents);
        $payload = $json->payload;
        $signature = $json->gpg_signed_data;

        syslog(LOG_WARNING, "TODO: Fix validation to work with just the public key");

        return $signature == AddressMachinePaymentKey::PayloadSignature($payload);

    }

    function load($publisher) {

        if (!$filename = $this->filename($publisher)) {
            syslog(LOG_DEBUG, "File {$this->filename($publisher)} does not exist, cannot validate signature.");
            return false;
        }

        $contents = file_get_contents($filename);

        $json = json_decode($contents);
        $payload = $json->payload;

        $this->address = $payload->address;
        $this->identifier = $payload->identifier;
        $this->identifierhash = $payload->identifierhash;
        $this->keytype = $payload->keytype;    
        $this->paymenttype = $payload->paymenttype;    
        $this->creationdate = $payload->creationdate;    
        $this->service = $payload->service;    
        $this->status = $payload->status;
        $this->gpg_signed_data = $payload->gpg_signed_data;

        return true;

    }

    public static function IdentifierHash($identifier) {

        return sha1(strtolower($identifier));

    }

    // The publisher flag allows us to use the same class to get information about where the file would live on our publishing server.
    // This will follow the same conventions and just have a different data root, although in theory it doesn't have to.
    public static function PathToSignedFiles($identifier = null, $identifierhash = null, $service, $keytype, $paymenttype, $publisher = false) {
        if (!$identifier && !$identifierhash) {
            syslog(LOG_WARNING, "No identifier supplied when trying to get path to signed files.");
            return null;
        }

        if (!$keytype) {
            syslog(LOG_WARNING, "No keytype supplied when trying to get path to signed files.");
            return null;
        }

        if (!$service) {
            syslog(LOG_WARNING, "No service supplied when trying to get path to signed files.");
            return null;
        }

        $service_paths = array(
            'twitter' => $publisher ? ADDRESSMACHINE_PUBLICATION_DIRECTORY_TWITTER : ADDRESSMACHINE_DATA_DIRECTORY_TWITTER,
            'email'   => $publisher ? ADDRESSMACHINE_PUBLICATION_DIRECTORY_EMAIL : ADDRESSMACHINE_DATA_DIRECTORY_EMAIL,
        );

        if (!isset($service_paths[$service])) {
            syslog(LOG_WARNING, "No service path known for service type $service when trying to get path to signed files.");
            return null;
        }

        if (!$service_path = $service_paths[$service]) {
            syslog(LOG_WARNING, "Empty service path for service type $service when trying to get path to signed files.");
            return null;
        }

        $paymenttype_paths = array(
            'bitcoin'  => 'bitcoin',
            'litecoin' => 'litecoin',
        );

        if (!$paymenttype_path  = $paymenttype_paths[$paymenttype]) {
            syslog(LOG_WARNING, "Payment type {$paymenttype} not known, no path for it.");
            return null;
        }
        
        if ($identifierhash) {
            if ($identifier) {
                if ($identifierhash != AddressMachinePaymentKey::IdentifierHash($identifier)) {
                    syslog(LOG_WARNING, "Identifier $identifier and identifier hash $identifierhash both set, but don't match");
                    return null;
                }
            }
        }

        if (!$identifierhash && !$identifierhash = AddressMachinePaymentKey::IdentifierHash($identifier)) {
            syslog(LOG_WARNING, "Could not make hash for identifier $identifier when trying to get path to signed files.");
            return null;
        }

        return $service_path.'/'.$paymenttype_path.'/'.$keytype.'/'.$identifierhash;

    }

    function seed() {

        if (!defined('ADDRESSMACHINE_ELECTRUM_SCRIPTABLE') || (ADDRESSMACHINE_ELECTRUM_SCRIPTABLE == '')) {
            syslog(LOG_ERR, "ADDRESSMACHINE_ELECTRUM_SCRIPTABLE not defined, cannot make a seed");
            return false;
        }
        if (!defined('ADDRESSMACHINE_ELECTRUM_WORKING_DIRECTORY') || (ADDRESSMACHINE_ELECTRUM_WORKING_DIRECTORY == '')) {
            syslog(LOG_ERR, "ADDRESSMACHINE_ELECTRUM_WORKING_DIRECTORY not defined, cannot make a seed");
            return false;
        }
        if (!file_exists(ADDRESSMACHINE_ELECTRUM_WORKING_DIRECTORY)) {
            syslog(LOG_ERR, "Electrum working directory ".ADDRESSMACHINE_ELECTRUM_WORKING_DIRECTORY." does not exist, cannot make a seed");
            return false;
        }

        $cmd = 'WALLET="'.ADDRESSMACHINE_ELECTRUM_WORKING_DIRECTORY.'/wallet$$" && '.ADDRESSMACHINE_ELECTRUM_SCRIPTABLE.' -o -g text -w "$WALLET" create | grep -B1 \'generation seed\' | perl -pe \'s/Your wallet generation seed is//g; s/\n//g; s/\s//g\' && rm $WALLET';

        $output = exec($cmd);

        $bits = explode(':', $output);
        if (count($bits) != 2) {
            syslog(LOG_ERR, "Wrong number of parameters our output format returned from electrum command.");
            return false;
        }
        $this->address = $bits[0];
        $this->seed = $bits[1];

        return true;

    }

}
