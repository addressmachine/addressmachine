<?php
// An identity represents something people may know you by, like a Twitter handle or and email address.
// We'll call plain text of the handle (as opposed to the object representing it) an "identifier".
abstract class AddressMachineIdentity {

    var $service;
    var $identifier;
    var $gpg_private_key;

    abstract static public function ForIdentifier($i);


    function pathToSignedTempFiles() {
        
        if ($this->identifier == '') {
            syslog(LOG_WARNING, "Cannot get pathToSignedTempFiles - identifier missing");
            return null;
        }

        return AddressMachineBitcoinKey::PathToSignedFiles($this->identifier, 'temp', $this->service);

    }

    function pathToSignedUserFiles() {
        
        if ($this->identifier == '') {
            syslog(LOG_WARNING, "Cannot get pathToSignedUserFiles - identifier missing");
            return null;
        }

        return AddressMachineBitcoinKey::PathToSignedFiles($this->identifier, 'user', $this->service);

    }

    // We keep two kinds of keys (Bitcoin addresses):  
    // User keys are registered by the user.
    // Temp keys are generated by us, in the hope that the user give us an address to pay to later.

    function userBitcoinKeys() {

        return $this->bitcoinKeysForType(ADDRESSMACHINE_KEY_TYPE_USER);

    }

    function tempBitcoinKeys() {
        
        return $this->bitcoinKeysForType(ADDRESSMACHINE_KEY_TYPE_TEMP);

    }

    function bitcoinKeysForType($keytype) {

        if (!$keytype) {
            syslog(LOG_WARNING, "Cannot get bitcoinKeysForType - type missing");
            return null;
        }

        if (!$identifier = $this->identifier) {
            syslog(LOG_WARNING, "Cannot get bitcoinKeysForType - identifier missing");
            return null;
        }

        if (!$service = $this->service) {
            syslog(LOG_WARNING, "Cannot get bitcoinKeysForType - service missing");
            return null;
        }

        if (!$dir = AddressMachineBitcoinKey::PathToSignedFiles($identifier, $service, $keytype)) {
            syslog(LOG_WARNING, "Cannot get bitcoinKeysForType - could not get path to signed files");
            return null;
        }

        if (!file_exists($dir)) {
            syslog(LOG_DEBUG, "Directory $dir does not exist, bitcoinKeysForType returning an empty array.");
            return array();
        }

        if (!$handle = opendir($dir)) {
            syslog(LOG_WARNING, "Directory $dir exists but could not be read, bitcoinKeysForType returning null.");
            return null;
        }

        $ret = array();

        while (false !== ($entry = readdir($handle))) {

            if ($entry == '.') {
                continue;    
            }

            if ($entry == '..') {
                continue;
            }

            $key = new AddressMachineBitcoinKey();
            $key->address = $entry;
            $key->identifier = $this->identifier;
            $key->service = $this->service;
            $key->keytype = $keytype;
            $ret[] = $key;

            syslog(LOG_DEBUG, "Found address entry for $entry .");

        }

        closedir($handle);

        return $ret;

    }

    function allBitcoinKeys() {

        return array_merge((array)$this->userBitcoinKeys(), (array)$this->tempBitcoinKeys());

    }

    function addTempBitcoinKeyByAddress($addr) {
        
        return $this->addBitcoinKeyByAddressAndKeyType($addr, ADDRESSMACHINE_KEY_TYPE_TEMP);
        
    }

    function tempBitcoinKeyForAddress($addr) {

        return $this->bitcoinKeyForAddressAndKeyType($addr, ADDRESSMACHINE_KEY_TYPE_TEMP);

    }

    function addUserBitcoinKeyByAddress($addr) {
       
        return $this->addBitcoinKeyByAddressAndKeyType($addr, ADDRESSMACHINE_KEY_TYPE_USER);
        
    }

    function userBitcoinKeyForAddress($addr) {

        return $this->bitcoinKeyForAddressAndKeyType($addr, ADDRESSMACHINE_KEY_TYPE_USER);

    }


    function addBitcoinKeyByAddressAndKeyType($addr, $keytype) {

        if (!$this->identifier) {
            return false;
        }
        
        $key = new AddressMachineBitcoinKey();
        $key->identifier = $this->identifier;
        $key->address = $addr;
        $key->keytype = ADDRESSMACHINE_KEY_TYPE_USER;
        $key->service = $this->service;

        if ($key->create()) {
            return $key;
        }

        return null;

    }

    function bitcoinKeyForAddressAndKeyType($addr, $keytype) {

        if (!$this->identifier) {
            return false;
        }
        
        $key = new AddressMachineBitcoinKey();
        $key->identifier = $this->identifier;
        $key->address = $addr;
        $key->keytype = ADDRESSMACHINE_KEY_TYPE_USER;
        $key->service = $this->service;

        if ($key->exists()) {
            return key;
        }

        return null;

    }

}

class AddressMachineTwitterIdentity extends AddressMachineIdentity {

    static public function ForIdentifier($id) {
        $i = new AddressMachineTwitterIdentity();
        $i->service = 'twitter';
        $i->identifier = $id;
        return $i;
    }

}

class AddressMachineEmailIdentity extends AddressMachineIdentity {

    static public function ForIdentifier($id) {
        $i = new AddressMachineEmailIdentity();
        $i->service = 'email';
        $i->identifier = $id;
        return $i;
    }


}

// Internally we call what is commonly called an "address" a key.
// This allows us to differentiate it from the address, which is the hash of the public key.
// In practice we will mostly manage addresses.
class AddressMachineBitcoinKey {

    var $address;
    var $identifier;
    var $keytype;
    var $service;

    function exists() {

        if (!$filename = $this->filename()) {
            syslog(LOG_DEBUG, "File {$this->filename()} does not exist.");
            return null;
        }

        return file_exists($filename);

    }

    function create() {

        if (!$address = $this->address) {
            syslog(LOG_WARNING, "Cannot create file for address - address not set.");
            return false;
        }

        if ($this->exists()) {
            syslog(LOG_WARNING, "File already exists, refusing to create.");
            return false;
        }

        if (!$path = $this->path()) {
            syslog(LOG_WARNING, "Creation failed, could not get path to place we create the file.");
            return false;
        }

        // If we don't already have a directory for this, create it.
        if (!file_exists($path)) {
            
            if (!mkdir( $path, ADDRESSMACHINE_ADDRESS_DIR_CREATION_MODE, true ) ) {

                // Check again in case it failed because another process made it in the meantime
                if (!file_exists($path)) {
                    syslog(LOG_ERR, "Directory creation failed for path $path.");
                    return false;
                }

            }

        }

        $file = $path.'/'.$address;
        $contents = $this->toJSON();

        if (!$handle = fopen($file, 'w')) {
                syslog(LOG_ERR, "Could not open file $file to write.");
                return false;
        }
        if (!flock($handle, 2)) {
            fclose($handle);
            syslog(LOG_ERR, "Could not lock file $file to write.");
            return false;
        }
        fputs($handle, $contents);
        fclose($handle);

        syslog(LOG_INFO, "Wrote new address $path.");

        return true;

    }

    function delete() {

        if (!$file = $this->filename()) {
            syslog(LOG_ERR, "Cannot get filename for deletion.");
            return false;
        }

        if (!file_exists($file)) {
            syslog(LOG_WARNING, "Cannot delete file $file - does not exist.");
            return false;
        }

        if (!@unlink($file)) {
            syslog(LOG_ERR, "Could not delete file $file.");
            return false;
        }

        syslog(LOG_INFO, "Deleted file $file");

        return true;

    }

    function toJSON() {
        $obj = new stdClass();
        $obj->address = $this->address;    
        return json_encode($obj);
    }

    function fromJSON($file_contents) {
        $obj = json_decode($file_contents);
        $this->address - $obj->address;
    }

    function path() {

        if (!$address = $this->address) {
            syslog(LOG_WARNING, "No address, can't make filename.");
            return null;
        }

        if (!$path = AddressMachineBitcoinKey::PathToSignedFiles($this->identifier, $this->service, $this->keytype)) {
            syslog(LOG_WARNING, "Could not get path to signed files.");
            return null;
        }

        return $path;

    }

    function filename() {

        if (!$address = $this->address) {
            syslog(LOG_WARNING, "Could not make filename - address not set.");
            return null;
        }

        if (!$path= $this->path()) {
            syslog(LOG_WARNING, "Could not make filename - could not get path to signed files.");
            return null;
        }

        return $path.'/'.$address;

    }

    function sign() {

        return false;

    }

    function revoke() {

        return false;

    }

    function save() {

        return false;

    }

    function isSignatureValid() {

        return false;

    }

    public static function IdentifierHash($identifier) {

        return sha1($identifier);

    }

    public static function PathToSignedFiles($identifier, $service, $keytype) {
        
        if (!$identifier) {
            syslog(LOG_WARNING, "No identifier supplied when trying to get path to signed files.");
            return null;
        }

        if (!$keytype) {
            syslog(LOG_WARNING, "No keytype supplied when trying to get path to signed files.");
            return null;
        }

        if (!$service) {
            syslog(LOG_WARNING, "No service supplied when trying to get path to signed files.");
            return null;
        }

        $service_paths = array(
            'twitter' => ADDRESSMACHINE_DATA_DIRECTORY_TWITTER,
            'email'   => ADDRESSMACHINE_DATA_DIRECTORY_EMAIL,
        );

        if (!isset($service_paths[$service])) {
            syslog(LOG_WARNING, "No service path known for service type $service when trying to get path to signed files.");
            return null;
        }

        if (!$service_path = $service_paths[$service]) {
            syslog(LOG_WARNING, "Empty service path for service type $service when trying to get path to signed files.");
            return null;
        }
        
        if (!$hash = AddressMachineBitcoinKey::IdentifierHash($identifier)) {
            syslog(LOG_WARNING, "Could not make hash for identifier $identifier when trying to get path to signed files.");
            return null;
        }

        return $service_path.'/'.$keytype.'/'.AddressMachineBitcoinKey::IdentifierHash($identifier);

    }

}
